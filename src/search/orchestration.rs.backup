use crate::transposition_table::TranspositionTable;
use crate::types::{format_square, Move, MoveList};
use crate::board::Board;
use crate::uci_info;
use crate::search_control;
use crate::constants;
use crate::ordering::OrderingContext;
use std::sync::{Arc, Mutex, mpsc::Sender};
use std::time::{Duration, Instant};

/// Iterative deepening search driver which publishes `uci_info::Info` messages to `info_sender`
/// and updates an optional sink with intermediate best moves.
pub fn iterative_deepening_with_sink(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_depth: u32,
    sink: Option<Arc<Mutex<Option<Move>>>>,
    info_sender: Option<Sender<uci_info::Info>>,
    is_ponder: bool,
) -> Option<Move> {
        let mut best_move: Option<Move> = None;

        let mut legal_moves: MoveList = MoveList::new();
        board.generate_moves_into(&mut legal_moves);
        if legal_moves.is_empty() {
            return None;
        }
        if legal_moves.len() == 1 {
            return Some(legal_moves[0]);
        }
        let mut root_moves = legal_moves;

        let search_start = Instant::now();
        let mut prev_score: Option<i32> = None;
        for depth in 1..=max_depth {
            // Bump TT generation so entries written at this depth are preferred
            tt.new_generation();
            // Progressive aspiration: if we have a previous score and depth is big enough,
            // try small windows around prev_score and widen (10,20,40,... up to 500 cp)
            let mut mv_opt: Option<Move> = None;
            let mut score: i32 = 0;
            let mut completed = false;

            if let Some(ps) = prev_score {
                if depth > 2 && ps.abs() < (constants::MATE_SCORE / 2) {
                    let mut margin = 10i32;
                    while margin <= 500 {
                        if search_control::should_stop() {
                            break;
                        }
                        let a = ps.saturating_sub(margin);
                        let b = ps.saturating_add(margin);
                        let (mv_try, sc_try, completed_try) = crate::search::run_root_search(
                            board,
                            tt,
                            depth,
                            &mut root_moves[..],
                            search_control::should_stop,
                            Some((a, b)),
                        );
                        if completed_try && sc_try > a && sc_try < b {
                            mv_opt = mv_try;
                            score = sc_try;
                            completed = true;
                            break;
                        }
                        if !completed_try && search_control::should_stop() {
                            break;
                        }
                        margin = margin.saturating_mul(2);
                    }
                }
            }

            // Fallback to full-window search if aspiration did not produce a completed result
            if !completed && !search_control::should_stop() {
                let (mv_full, sc_full, completed_full) = crate::search::run_root_search(
                    board,
                    tt,
                    depth,
                    &mut root_moves[..],
                    search_control::should_stop,
                    None,
                );
                mv_opt = mv_full;
                score = sc_full;
                completed = completed_full;
            }

            if completed {
                if let Some(mv) = mv_opt {
                    best_move = Some(mv);

                    if let Some(ref s) = sink {
                        let mut lock = match s.lock() {
                            Ok(g) => g,
                            Err(poisoned) => {
                                eprintln!("warning: sink mutex poisoned, recovering");
                                poisoned.into_inner()
                            }
                        };
                        *lock = best_move;
                    }

                    if let Some(ref sender) = info_sender {
                        let nodes_total = search_control::get_node_count();
                        let elapsed_ms = search_start.elapsed().as_millis();
                        let nps = if elapsed_ms > 0 {
                            Some(((nodes_total as u128 * 1000) / elapsed_ms) as u64)
                        } else {
                            None
                        };
                        let pv = crate::search::build_pv_from_tt(tt, board.hash);
                        let mut info = uci_info::Info {
                            depth: Some(depth),
                            nodes: Some(nodes_total),
                            nps,
                            time_ms: Some(elapsed_ms),
                            score_cp: None,
                            score_mate: None,
                            pv: Some(pv),
                            seldepth: Some(depth),
                            ponder: None,
                        };
                        if score.abs() > (constants::MATE_SCORE / 2) {
                            let mate_in = (constants::MATE_SCORE - score.abs() + 1) / 2;
                            info.score_mate = Some(mate_in);
                        } else {
                            info.score_cp = Some(score);
                        }
                        if is_ponder {
                            if let Some(bm) = best_move {
                                info.ponder = Some(format!("{}{}", format_square(bm.from), format_square(bm.to)));
                            }
                        }
                        let _ = sender.send(info);
                    }

                    if let Some(pos) = root_moves.iter().position(|m| *m == mv) {
                        root_moves.swap(0, pos);
                    }
                    // record previous score for next depth's aspiration window
                    prev_score = Some(score);
                }
            }

        best_move
}

/// Time-limited iterative deepening driver.
pub fn time_limited_search_with_sink(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_time: Duration,
    start_time: Instant,
    sink: Option<Arc<Mutex<Option<Move>>>>,
    info_sender: Option<Sender<uci_info::Info>>,
    is_ponder: bool,
) -> Option<Move> {
        let mut best_move: Option<Move> = None;
        let mut depth = 1u32;
        let mut last_depth_time = Duration::from_millis(1);

        const SAFETY_MARGIN: Duration = Duration::from_millis(5);
        const TIME_GROWTH_FACTOR: f32 = 2.0;

        let mut prev_score: Option<i32> = None;
        while start_time.elapsed() + SAFETY_MARGIN < max_time {
            // Bump generation each iterative step so TT replacement prefers newer entries
            tt.new_generation();
            let elapsed = start_time.elapsed();
            let time_remaining = max_time.checked_sub(elapsed).unwrap_or_default();

            let estimated_next_time = last_depth_time.mul_f32(TIME_GROWTH_FACTOR);
            if estimated_next_time + SAFETY_MARGIN > time_remaining {
                break;
            }

            let depth_start = Instant::now();

            let mut legal_moves: MoveList = MoveList::new();
            board.generate_moves_into(&mut legal_moves);
            if legal_moves.is_empty() {
                return None;
            }
            if legal_moves.len() == 1 {
                return Some(legal_moves[0]);
            }

            legal_moves.sort_by_key(|m| -crate::board::mvv_lva_score(m, board));
            crate::search::apply_tt_move_hint(&mut legal_moves[..], tt, board.hash);

            // Progressive aspiration similar to iterative driver
            let mut this_best_move: Option<Move> = None;
            let mut this_best_score: i32 = 0;
            let mut completed = false;
            if let Some(ps) = prev_score {
                if depth > 2 && ps.abs() < (constants::MATE_SCORE / 2) {
                    let mut margin = 10i32;
                    while margin <= 500 {
                        if start_time.elapsed() + SAFETY_MARGIN >= max_time {
                            break;
                        }
                        let a = ps.saturating_sub(margin);
                        let b = ps.saturating_add(margin);
                        let (mv_try, sc_try, completed_try) = crate::search::run_root_search(
                            board,
                            tt,
                            depth,
                            &mut legal_moves[..],
                            || start_time.elapsed() + SAFETY_MARGIN >= max_time || search_control::should_stop(),
                            Some((a, b)),
                        );
                        if completed_try && sc_try > a && sc_try < b {
                            this_best_move = mv_try;
                            this_best_score = sc_try;
                            completed = true;
                            break;
                        }
                        if !completed_try && (start_time.elapsed() + SAFETY_MARGIN >= max_time || search_control::should_stop()) {
                            break;
                        }
                        margin = margin.saturating_mul(2);
                    }
                }
            }

            if !completed {
                let (mv_full, sc_full, completed_full) = crate::search::run_root_search(
                    board,
                    tt,
                    depth,
                    &mut legal_moves[..],
                    || start_time.elapsed() + SAFETY_MARGIN >= max_time || search_control::should_stop(),
                    None,
                );
                if completed_full {
                    this_best_move = mv_full;
                    this_best_score = sc_full;
                    completed = true;
                }
            }

            if start_time.elapsed() + SAFETY_MARGIN < max_time {
                if completed {
                    best_move = this_best_move;
                    if let Some(ref s) = sink {
                        let mut lock = match s.lock() {
                            Ok(g) => g,
                            Err(poisoned) => {
                                eprintln!("warning: sink mutex poisoned, recovering");
                                poisoned.into_inner()
                            }
                        };
                        *lock = best_move;
                    }

                    if let Some(ref sender) = info_sender {
                        let nodes_total = search_control::get_node_count();
                        let elapsed_ms = start_time.elapsed().as_millis();
                        let nps = if elapsed_ms > 0 {
                            Some(((nodes_total as u128 * 1000) / elapsed_ms) as u64)
                        } else {
                            None
                        };
                        let pv = crate::search::build_pv_from_tt(tt, board.hash);
                        let mut info = uci_info::Info {
                            depth: Some(depth),
                            nodes: Some(nodes_total),
                            nps,
                            time_ms: Some(elapsed_ms),
                            score_cp: None,
                            score_mate: None,
                            pv: Some(pv),
                            seldepth: None,
                            ponder: None,
                        };
                        if this_best_score.abs() > (constants::MATE_SCORE / 2) {
                            let mate_in = (constants::MATE_SCORE - this_best_score.abs() + 1) / 2;
                            info.score_mate = Some(mate_in);
                        } else {
                            info.score_cp = Some(this_best_score);
                        }
                        if is_ponder {
                            if let Some(bm) = best_move {
                                info.ponder = Some(format!("{}{}", format_square(bm.from), format_square(bm.to)));
                            }
                        }
                        let _ = sender.send(info);
                    }

                    // rotate best move to front in root moves
                    if let Some(bm) = best_move {
                        if let Some(pos) = legal_moves.iter().position(|m| *m == bm) {
                            legal_moves.swap(0, pos);
                        }
                    }
                    // record prev_score for next depth's aspiration window
                    prev_score = Some(this_best_score);
                }

                last_depth_time = depth_start.elapsed();
                depth += 1;
            } else {
                break;
            }
        }

        best_move
use std::time::{Duration, Instant};

/// Convenience function to find the best move using depth-limited search
pub fn find_best_move(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_depth: u32,
) -> Option<Move> {
    find_best_move_with_context(board, tt, max_depth, None, None, false)
}

/// Find the best move using iterative deepening with optional sinks and info publishing.
///
/// - `board`: the current position to search.
/// - `tt`: transposition table used for move ordering and PV extraction.
/// - `max_depth`: maximum depth to search.
/// - `sink`: optional Arc<Mutex<Option<Move>>> updated with intermediate best moves.
/// - `info_sender`: optional sender for structured UCI info messages.
/// - `_is_ponder`: set to true when this is a ponder search (used for UCI `ponder` info).
pub fn find_best_move_with_context(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_depth: u32,
    sink: Option<std::sync::Arc<std::sync::Mutex<Option<Move>>>>,
    info_sender: Option<std::sync::mpsc::Sender<crate::uci_info::Info>>,
    _is_ponder: bool,
) -> Option<Move> {
    let mut best_move: Option<Move> = None;
    let mut _best_score = -MATE_SCORE * 2;

    let mut legal_moves: crate::types::MoveList = crate::types::MoveList::new();
    board.generate_moves_into(&mut legal_moves);
    if legal_moves.is_empty() {
        return None;
    }
    if legal_moves.len() == 1 {
        return Some(legal_moves[0]); // No need to search further
    }
    let mut root_moves = legal_moves; // Reuse for move ordering (moved instead of clone)

    // Helper to build a PV string from the transposition table starting at the current hash
    fn build_pv_string(tt: &TranspositionTable, start_hash: u64) -> String {
        let mut pv = Vec::new();
        if let Some(entry) = tt.probe(start_hash) {
            if let Some(mv) = entry.best_move {
                pv.push(mv);
            }
        }
        let pv_strs: Vec<String> = pv
            .iter()
            .map(|m| format!("{}{}", crate::types::format_square(m.from), crate::types::format_square(m.to)))
            .collect();
        pv_strs.join(" ")
    }

    // Iterative Deepening Loop
    let search_start = Instant::now();

    for depth in 1..=max_depth {
        let _depth_start = Instant::now();
        let _nodes_before = crate::search_control::get_node_count();
        let mut alpha = -MATE_SCORE * 2;
        let beta = MATE_SCORE * 2;
        let mut current_best_score = -MATE_SCORE * 2;
        let mut current_best_move: Option<Move> = None;

        // Optional: order moves using hash move from TT
        if let Some(entry) = tt.probe(board.hash) {
            if let Some(hm) = &entry.best_move {
                if let Some(pos) = root_moves.iter().position(|m| m == hm) {
                    root_moves.swap(0, pos);
                }
            }
        }

        // Temporary moves buffer to pass into recursive negamax/quiesce calls
    let mut mv_buf: crate::types::MoveList = crate::types::MoveList::new();
        for m in &root_moves {
            let info = board.make_move(m);
            let score = -crate::search::algorithms::negamax(board, tt, depth - 1, -beta, -alpha, &mut mv_buf, &mut crate::ordering::OrderingContext::new(256));
            board.unmake_move(m, info);

            if score > current_best_score {
                current_best_score = score;
                current_best_move = Some(*m);
            }

            alpha = alpha.max(current_best_score);
        }

        if let Some(mv) = current_best_move {
            _best_score = current_best_score;
            best_move = Some(mv);

            // publish intermediate best move to sink if provided
            if let Some(ref s) = sink {
                let mut lock = match s.lock() {
                    Ok(g) => g,
                    Err(poisoned) => {
                        eprintln!("warning: sink mutex poisoned, recovering");
                        poisoned.into_inner()
                    }
                };
                *lock = best_move;
            }

            // Build structured Info and send to the info channel if present
            if let Some(ref sender) = info_sender {
                let nodes_after = crate::search_control::get_node_count();
                let nodes_total = nodes_after;
                let elapsed_ms = search_start.elapsed().as_millis();
                let nps = if elapsed_ms > 0 {
                    Some(((nodes_total as u128 * 1000) / elapsed_ms) as u64)
                } else {
                    None
                };
                let pv = build_pv_string(tt, board.hash);
                let mut info = crate::uci_info::Info {
                    depth: Some(depth),
                    nodes: Some(nodes_total),
                    nps,
                    time_ms: Some(elapsed_ms),
                    score_cp: None,
                    score_mate: None,
                    pv: Some(pv.clone()),
                    seldepth: Some(depth),
                    ponder: None,
                };
                if _best_score.abs() > (MATE_SCORE / 2) {
                    let mate_in = (MATE_SCORE - _best_score.abs() + 1) / 2;
                    info.score_mate = Some(mate_in);
                } else {
                    info.score_cp = Some(_best_score);
                }
                // If the caller indicated we are pondering, include the best move as 'ponder'
                if _is_ponder {
                    if let Some(bm) = best_move {
                        info.ponder = Some(format!(
                            "{}{}",
                            crate::types::format_square(bm.from),
                            crate::types::format_square(bm.to)
                        ));
                    }
                }
                let _ = sender.send(info);
            }

            // Optional: reorder root_moves so best move is searched first in next iteration
            if let Some(pos) = root_moves.iter().position(|m| *m == mv) {
                root_moves.swap(0, pos);
            }
        }
    }

    best_move
}

pub fn find_best_move_with_time_context(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_time: Duration,
    start_time: Instant,
    sink: Option<std::sync::Arc<std::sync::Mutex<Option<Move>>>>,
    info_sender: Option<std::sync::mpsc::Sender<crate::uci_info::Info>>,
    _is_ponder: bool,
) -> Option<Move> {
    let mut best_move: Option<Move> = None;
    let mut depth = 1;
    let mut last_depth_time = Duration::from_millis(1); // Prevent div-by-zero on first estimate

    const SAFETY_MARGIN: Duration = Duration::from_millis(5);
    const TIME_GROWTH_FACTOR: f32 = 2.0; // Each depth takes ~2× longer

    while start_time.elapsed() + SAFETY_MARGIN < max_time {
        let elapsed = start_time.elapsed();
        let time_remaining = max_time.checked_sub(elapsed).unwrap_or_default();

        // Estimate whether we have enough time for the next depth
        let estimated_next_time = last_depth_time.mul_f32(TIME_GROWTH_FACTOR);
        if estimated_next_time + SAFETY_MARGIN > time_remaining {
            break; // Not enough time for another full depth
        }

        let depth_start = Instant::now();

        let mut alpha = -MATE_SCORE * 2;
        let beta = MATE_SCORE * 2;
        let mut best_score = -MATE_SCORE * 2;
    let mut legal_moves: crate::types::MoveList = crate::types::MoveList::new();
    board.generate_moves_into(&mut legal_moves);

        if legal_moves.is_empty() {
            return None;
        }

        if legal_moves.len() == 1 {
            return Some(legal_moves[0]); // No need to search further
        }

        // MVV-LVA and TT move ordering
        legal_moves.sort_by_key(|m| -crate::board::mvv_lva_score(m, board));
        if let Some(entry) = tt.probe(board.hash) {
            if let Some(hm) = &entry.best_move {
                if let Some(pos) = legal_moves.iter().position(|m| m == hm) {
                    legal_moves.swap(0, pos);
                }
            }
        }

        let mut new_best_move = None;

        // Temporary moves buffer reused for recursive calls
    let mut mv_buf: crate::types::MoveList = crate::types::MoveList::new();
        for m in &legal_moves {
            if start_time.elapsed() + SAFETY_MARGIN >= max_time {
                break;
            }

            let info = board.make_move(m);
            let score = -crate::search::algorithms::negamax(board, tt, depth - 1, -beta, -alpha, &mut mv_buf, &mut crate::ordering::OrderingContext::new(256));
            board.unmake_move(m, info);

            if score > best_score {
                best_score = score;
                new_best_move = Some(*m);
            }

            alpha = alpha.max(best_score);
        }

        // Only update result if completed full depth in time
        if start_time.elapsed() + SAFETY_MARGIN < max_time {
            best_move = new_best_move;
            // publish best move for this depth
            if let Some(ref s) = sink {
                let mut lock = match s.lock() {
                    Ok(g) => g,
                    Err(poisoned) => {
                        eprintln!("warning: sink mutex poisoned, recovering");
                        poisoned.into_inner()
                    }
                };
                *lock = best_move;
            }

            // Send structured Info via channel if available
            if let Some(ref sender) = info_sender {
                // Build PV by cloning board and following TT best moves
                fn build_pv_using_board(
                    orig: &Board,
                    tt: &TranspositionTable,
                    max_ply: usize,
                ) -> String {
                    let mut b = orig.clone();
                    let mut pv = Vec::new();
                    for _ in 0..max_ply {
                        if let Some(entry) = tt.probe(b.hash) {
                            if let Some(mv) = entry.best_move {
                                pv.push(mv);
                                let _info = b.make_move(&mv);
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    let pv_strs: Vec<String> = pv
                        .iter()
                        .map(|m| format!("{}{}", crate::types::format_square(m.from), crate::types::format_square(m.to)))
                        .collect();
                    pv_strs.join(" ")
                }

                let nodes_total = crate::search_control::get_node_count();
                let elapsed_ms = start_time.elapsed().as_millis();
                let nps = if elapsed_ms > 0 {
                    Some(((nodes_total as u128 * 1000) / elapsed_ms) as u64)
                } else {
                    None
                };
                let pv = build_pv_using_board(board, tt, 20);
                let mut info = crate::uci_info::Info {
                    depth: Some(depth),
                    nodes: Some(nodes_total),
                    nps,
                    time_ms: Some(elapsed_ms),
                    score_cp: None,
                    score_mate: None,
                    pv: Some(pv),
                    seldepth: None,
                    ponder: None,
                };
                if best_score.abs() > (MATE_SCORE / 2) {
                    let mate_in = (MATE_SCORE - best_score.abs() + 1) / 2;
                    info.score_mate = Some(mate_in);
                } else {
                    info.score_cp = Some(best_score);
                }
                if _is_ponder {
                    if let Some(bm) = best_move {
                        info.ponder = Some(format!(
                            "{}{}",
                            crate::types::format_square(bm.from),
                            crate::types::format_square(bm.to)
                        ));
                    }
                }
                let _ = sender.send(info);
            }

            last_depth_time = depth_start.elapsed();
            depth += 1;
        } else {
            break;
        }
    }

    best_move
}

#[allow(dead_code)]
pub fn find_best_move_with_time_with_sink(
    board: &mut Board,
    tt: &mut TranspositionTable,
    max_time: Duration,
    start_time: Instant,
    sink: Option<std::sync::Arc<std::sync::Mutex<Option<Move>>>>,
    info_sender: Option<std::sync::mpsc::Sender<crate::uci_info::Info>>,
    is_ponder: bool,
) -> Option<Move> {
    find_best_move_with_time_context(board, tt, max_time, start_time, sink, info_sender, is_ponder)
}
